---
layout: post
title: "高程-第十五章-canvas"
subtitle: ""
date: 2019-08-27 12:00:00
author: "左手喝水"
header-img: "img/post-bg-2015.jpg"
tags:
  - js
---

### 基本用法

- getContext: 获得 canvas 的上下文，传入参数'2d'则为 2d 绘图类型上下文；通过检测是否有 getContext 方法来判断浏览器是否支持 canvas
- toDataUrl:导出在 canvas 上绘制的图片，如果绘制到画布上的图像源自不同的域，toDataURL()方法会抛出错误。导出图片代码如下

```js
var drawing = document.getElementById("drawing");
//确定浏览器支持<canvas>元素
if (drawing.getContext) {
  //取得图像的数据 URI
  var imgURI = drawing.toDataURL("image/png");
  //显示图像
  var image = document.createElement("img");
  image.src = imgURI;
  document.body.appendChild(image);
}
```

### 2D 上下文

使用 2D 绘图上下文提供的方法，可以绘制简单的 2D 图形，比如矩形、弧线和路径。2D 上下文的坐标开始于 canvas 元素的左上角，原点坐标是(0,0)。
默认情况下，width 和 height 表示水平和垂直两个方向上可用的像素数目。

#### 填充和描边

fillStyle：填充样式
strokeStyle：描边样式

#### 绘制矩形

以下个方法都能接收 4 个参数(单位为像素):

- 矩形的 x 坐标
- 矩形的 y 坐标
- 矩形 宽度
- 矩形高度

fillRect()：绘制矩形并填充指定的颜色，填充的颜色通过 fillstye 来完成

strokeRect()：在画布上绘制的矩形会使用指定的颜色描边。描边颜色通过 strokeStyle 属性指定；

clearRect()：用于清除画布上的矩形区域。本质上，这个方法可以把绘制上下文中的某 一矩形区域变透明

#### 绘制路径

要绘制路径，首先必须调用 beginPath()方法，表示要开始 绘制新路径。然后，再通过调用下列方法来实际地绘制路径。

- arc(x, y, radius, startAngle, endAngle, counterclockwise):以(x,y)为圆心绘 制一条弧线，弧线半径为 radius，起始和结束角度(用弧度表示)分别为 startAngle 和 endAngle。最后一个参数表示 startAngle 和 endAngle 是否按逆时针方向计算，值为 false 表示按顺时针方向计算。
- arcTo(x1, y1, x2, y2, radius):从上一点开始绘制一条弧线，到(x2,y2)为止，并且以 给定的半径 radius 穿过(x1,y1)。
- bezierCurveTo(c1x, c1y, c2x, c2y, x, y):从上一点开始绘制一条曲线，到(x,y)为 止，并且以(c1x,c1y)和(c2x,c2y)为控制点。
- lineTo(x, y):从上一点开始绘制一条直线，到(x,y)为止。
- moveTo(x, y):将绘图游标移动到(x,y)，不画线。
- quadraticCurveTo(cx, cy, x, y):从上一点开始绘制一条二次曲线，到(x,y)为止，并
  且以(cx,cy)作为控制点。
- rect(x, y, width, height):从点(x,y)开始绘制一个矩形，宽度和高度分别由 width 和
  height 指定。这个方法绘制的是矩形路径，而不是 strokeRect()和 fillRect()所绘制的独
  立的形状。
- isPointInPath(x,y): 用于在路径被关闭之前确定画布上的某一点是否位于路径上

#### 绘制文本

绘制文本主要有两个 方法:fillText()和 strokeText()。这两个方法都可以接收 4 个参数:要绘制的文本字符串、x 坐 标、y 坐标和可选的最大像素宽度。而且，这两个方法都以下列 3 个属性为基础。

- font:表示文本样式、大小及字体，用 CSS 中指定字体的格式来指定，例如"10px Arial"。
- textAlign:表示文本对齐方式。可能的值有"start"、"end"、"left"、"right"和"center"。
  建议使用"start"和"end"，不要使用"left"和"right"，因为前两者的意思更稳妥，能同时适合从左到右和从右到左显示(阅读)的语言。
- textBaseline:表示文本的基线。可能的值有"top"、"hanging"、"middle"、"alphabetic"、
  "ideographic"和"bottom"。

measureText()方法利用 font、textAlign 和 textBaseline 的当前值计算指定文本的大小。
示例

```js
var fontSize = 100;
context.font = fontSize + "px Arial";
while (context.measureText("Hello world!").width > 140) {
  fontSize--;
  context.font = fontSize + "px Arial";
}
context.fillText("Hello world!", 10, 10);
context.fillText("Font size is " + fontSize + "px", 10, 50);
```

#### 变换

变形 canvas 绘图主要有以下 api：

- rotate(angle):围绕原点旋转图像 angle 弧度。 8  scale(scaleX, scaleY):缩放图像，在 x 方向乘以 scaleX，在 y 方向乘以 scaleY。scaleX
  和 scaleY 的默认值都是 1.0。
- translate(x,y):将坐标原点移动到(x,y)。执行这个变换之后，坐标(0,0)会变成之前由(x,y) 9
  表示的点。
- transform(m1_1, m1_2, m2_1, m2_2, dx, dy):直接修改变换矩阵，方式是乘以如下矩阵
  m1_1 m1_2 dx
  m2_1 m2_2 dy
  0 0 1
- setTransform(m1_1, m1_2, m2_1, m2_2, dx, dy):将变换矩阵重置为默认状态，然后 再调用 transform()。

保存当前上下文状态（如：填充颜色，描边颜色等设置）使用 save()，保存在一个栈中，可以多次保存把状态放入栈中；使用保存的状态使用 restore()，从栈定弹出最后保存的状态；

#### 绘制图像

drawImage():绘制图片到画布上。
最简单的调用方式 是传入一个 HTML <img>元素，以及绘制该图像的起点的 x 和 y 坐标。

```js
var image = document.images[0];
context.drawImage(image, 10, 10);

// 指定图像大小（单位像素）
context.drawImage(image, 50, 10, 20, 30);

// 指定图像一部分绘入指定区域
context.drawImage(image, 0, 10, 50, 50, 0, 100, 40, 60);
```

#### 阴影

2D 上下文会根据以下几个属性的值，自动为形状或路径绘制出阴影。

- shadowColor:用 CSS 颜色格式表示的阴影颜色，默认为黑色。
- shadowOffsetX:形状或路径 x 轴方向的阴影偏移量，默认为 0。
- shadowOffsetY:形状或路径 y 轴方向的阴影偏移量，默认为 0。
- shadowBlur:模糊的像素数，默认 0，即不模糊。

#### 渐变

createLinearGradient()：这个方法接收 4 个参数:起点的 x 坐标、起点的 y 坐 标、终点的 x 坐标、终点的 y 坐标。调用这个方法后，它就会创建一个指定大小的渐变，并返回 CanvasGradient 对象的实例。
创建了渐变对象后，下一步就是使用 addColorStop()方法来指定色标。这个方法接收两个参数: 色标位置和 CSS 颜色值。色标位置是一个 0(开始的颜色)到 1(结束的颜色)之间的数字。  
为了让渐变覆盖整个矩形，而不是仅应用到矩形的一部分，矩形和渐变对 象的坐标必须匹配才行。如果没有把矩形绘制到恰当的位置，那可能就只会显示部分渐变效果。 <br />
createRadialGradient():这个方法接收 6 个参 数，对应着两个圆的圆心和半径。前三个参数指定的是起点圆的原心(x 和 y)及半径，后三个参数指 定的是终点圆的原心(x 和 y)及半径。可以把径向渐变想象成一个长圆桶，而这 6 个参数定义的正是 这个桶的两个圆形开口的位置。如果把一个圆形开口定义得比另一个小一些，那这个圆桶就变成了圆锥 体，而通过移动每个圆形开口的位置，就可达到像旋转这个圆锥体一样的效果。

#### 模式

模式其实就是重复的图像，可以用来填充或描边图形。要创建一个新模式，可以调用 createPattern()方法并传入两个参数:一个 HTML <img>元素和一个表示如何重复图像的字符串。 其中，第二个参数的值与 CSS 的 background-repeat 属性值相同，包括"repeat"、"repeat-x"、 "repeat-y"和"no-repeat"。看一个例子。
需要注意的是，模式与渐变一样，都是从画布的原点(0,0)开始的。将填充样式(fillStyle)设置 为模式对象，只表示在某个特定的区域内显示重复的图像，而不是要从某个位置开始绘制重复的图像。
createPattern()方法的第一个参数也可以是一个 video 元素，或者另一个 canvas 元素。

#### 使用图像数据

2D 上下文的一个明显的长处就是，可以通过 getImageData()取得原始图像数据。这个方法接收 4 个参数:要取得其数据的画面区域的 x 和 y 坐标以及该区域的像素宽度和高度。例如，要取得左上角 坐标为(10,5)、大小为 50×50 像素的区域的图像数据，可以使用以下代码:

```js
var imageData = context.getImageData(10, 5, 50, 50);
```

这里返回的对象是 ImageData 的实例。每个 ImageData 对象都有三个属性:width、height 和
data。其中 data 属性是一个数组，保存着图像中每一个像素的数据。在 data 数组中，每一个像素用 4 个元素来保存，分别表示红、绿、蓝和透明度值。因此，第一个像素的数据就保存在数组的第 0 到第
3 个元素中，例如:

```js
var data = imageData.data,
  red = data[0],
  green = data[1],
  blue = data[2],
  alpha = data[3];
```

#### 合成

还有两个会应用到 2D 上下文中所有绘制操作的属性:globalAlpha 和 globalCompositionOperation。

- globalAlpha 是一个介于 0 和 1 之间的值(包括 0 和 1)，用于指定所有绘制的透 明度。默认值为 0。
- globalCompositionOperation:表示后绘制的图形怎样与先绘制的图形结合。这个 属性的值是字符串:
  source-over(默认值):后绘制的图形位于先绘制的图形上方。
  source-in:后绘制的图形与先绘制的图形重叠的部分可见，两者其他部分完全透明。
  source-out:后绘制的图形与先绘制的图形不重叠的部分可见，先绘制的图形完全透明。
  source-atop:后绘制的图形与先绘制的图形重叠的部分可见，先绘制图形不受影响。
  destination-over:后绘制的图形位于先绘制的图形下方，只有之前透明像素下的部分才可见。
  destination-in:后绘制的图形位于先绘制的图形下方，两者不重叠的部分完全透明。
  destination-out:后绘制的图形擦除与先绘制的图形重叠的部分。
  destination-atop:后绘制的图形位于先绘制的图形下方，在两者不重叠的地方，先绘制的

### webgl

WebGL 是针对 Canvas 的 3D 上下文。与其他 Web 技术不同，WebGL 并不是 W3C 制定的标准，而是由 Khronos Group 制定的。其官方网站是这样介绍的:“Khronos Group 是一个非盈利的由会员资助的协会，专注于为并行计算以及各种平台和设备上的图形及动态媒体制定无版税的开放标准。” Khronos Group 也设计了其他图形处理 API，比如 OpenGL ES 2.0。浏览器中使用的 WebGL 就是基于 OpenGL ES 2.0 制定的。

### 书中案例

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>canvas</title>
  </head>
  <body>
    <canvas id="drawing" width="400" height="400"> </canvas>
    <img
      src="file:///Users/shinho/Desktop/canvas/canvas-test2.jpeg"
      alt=""
      style="display: none"
    />
    <!-- <img src="file:///Users/shinho/Desktop/canvas-test2.jpeg" alt="" /> -->
    <!-- 顶点着色器 -->
    <script type="x-shader/x-vertex" id="shader-vs">
      void main(){
          gl_Position=vec4(0.0,0.0,0.0,1.0);
          gl_PointSize=100.0;
      }
    </script>
    <!-- 片段着色器 -->
    <script type="x-shader/x-fragment" id="shader-fs">
      void main(){
          gl_FragColor=vec4(1.0,1.0,0.0,1.0);
      }
    </script>

    <script>
      checkIsSupportCanvas();
      var typeEnum = {
        fillStyle: "fillStyle",
        strokeStyle: "strokeStyle",
        clearRect: "clearRect",
        clock: "clock",
        rotate: "rotate",
        image: "image",
        shadow: "shadow",
        linearGradient: "linearGradient",
        radial: "radial",
        pattern: "pattern",
        getImageData: "getImageData",
        globalAlpha: "globalAlpha",
        globalCompositionOperation: "globalCompositionOperation",
        webgl: "webgl"
      };
      var type = typeEnum.fillStyle;
      var drawing = document.getElementById("drawing");
      var context, gl;
      getContext();
      draw();

      function getContext() {
        if (/^webgl/.test(type)) {
          gl = drawing.getContext("webgl");
        } else {
          context = drawing.getContext("2d");
        }
      }

      function draw() {
        window[`${type}Example`]();
      }

      function fillStyleExample() {
        //绘制红色矩形
        context.fillStyle = "#ff0000";
        context.fillRect(10, 10, 50, 50);

        //绘制半透明的蓝色矩形
        context.fillStyle = "rgba(0,0,255,0.5)";
        context.fillRect(30, 30, 50, 50);
      }

      function strokeStyleExample() {
        //绘制红色描边矩形
        context.strokeStyle = "#ff0000";
        context.strokeRect(10, 10, 50, 50);
        //绘制半透明的蓝色描边矩形
        context.strokeStyle = "rgba(0,0,255,0.5)";
        context.strokeRect(30, 30, 50, 50);
      }

      function clearRectExample() {
        context.fillStyle = "#ff0000";
        context.fillRect(10, 10, 50, 50);
        //绘制半透明的蓝色矩形
        context.fillStyle = "rgba(0,0,255,0.5)";
        context.fillRect(30, 30, 50, 50);
        //在两个矩形重叠的地方清除一个小矩形
        context.clearRect(40, 40, 10, 10);
      }

      function clockExample() {
        //开始路径
        context.beginPath();
        //绘制外圆
        context.arc(100, 100, 99, 0, 2 * Math.PI, false);
        //绘制内圆
        context.moveTo(194, 100);
        context.arc(100, 100, 94, 0, 2 * Math.PI, false);
        //绘制分针
        context.moveTo(100, 100);
        context.lineTo(100, 15);
        //绘制时针
        context.moveTo(100, 100);
        context.lineTo(35, 100);
        //描边路径
        context.stroke();

        context.font = "bold 14px Arial";
        context.textAlign = "center";
        context.textBaseline = "middle";
        context.fillText("12", 100, 20);
      }
      function rotateExample() {
        //绘制外圆
        context.arc(100, 100, 99, 0, 2 * Math.PI, false);
        //绘制内圆
        context.moveTo(194, 100);
        context.arc(100, 100, 94, 0, 2 * Math.PI, false);
        //变换原点
        context.translate(100, 100);
        //旋转表针
        context.rotate(1);
        context.moveTo(0, 0);
        context.lineTo(0, -85);
        //绘制时针
        context.moveTo(0, 0);
        context.lineTo(-65, 0);
        //描边路径
        context.stroke();
      }

      function imageExample() {
        var image = document.images[0];
        image.onload = function() {
          context.drawImage(image, 10, 10, 50, 50);
        };
      }

      function shadowExample() {
        //设置阴影
        context.shadowOffsetX = 5;
        context.shadowOffsetY = 5;
        context.shadowBlur = 4;
        context.shadowColor = "rgba(0, 0, 0, 0.5)";
        //绘制红色矩形
        context.fillStyle = "#ff0000";
        context.fillRect(10, 10, 50, 50);
        //绘制蓝色矩形
        context.fillStyle = "rgba(0,0,255,1)";
        context.fillRect(30, 30, 50, 50);
      }

      function linearGradientExample() {
        var gradient = context.createLinearGradient(30, 30, 70, 70);
        gradient.addColorStop(0, "white");
        gradient.addColorStop(1, "black");
        //绘制红色矩形
        context.fillStyle = "#ff0000";
        context.fillRect(10, 10, 50, 50);
        //绘制渐变矩形
        context.fillStyle = gradient;
        context.fillRect(30, 30, 50, 50);
      }
      function radialExample() {
        var gradient = context.createRadialGradient(55, 55, 10, 55, 55, 30);
        gradient.addColorStop(0, "white");
        gradient.addColorStop(1, "black");
        //绘制红色矩形
        context.fillStyle = "#ff0000";
        context.fillRect(10, 10, 50, 50);
        //绘制渐变矩形
        context.fillStyle = gradient;
        context.fillRect(30, 30, 50, 50);
      }
      function patternExample() {
        var image = document.images[0];
        image.onload = function() {
          var pattern = context.createPattern(image, "repeat");
          //绘制矩形
          context.fillStyle = pattern;
          context.fillRect(0, 0, 400, 400);
        };
      }
      // FIX: 图片跨越
      function getImageDataExample() {
        var image = document.images[0],
          imageData,
          data,
          i,
          len,
          average,
          red,
          green,
          blue,
          alpha;
        image.crossOrigin = "";
        image.onload = function() {
          //绘制原始图像
          context.drawImage(image, 0, 0);
          //取得图像数据
          imageData = context.getImageData(0, 0, image.width, image.height);
          data = imageData.data;
          for (i = 0, len = data.length; i < len; i += 4) {
            red = data[i];
            green = data[i + 1];
            blue = data[i + 2];
            alpha = data[i + 3];
            //求得 rgb 平均值
            average = Math.floor((red + green + blue) / 3);
            //设置颜色值，透明度不变
            data[i] = average;
            data[i + 1] = average;
            data[i + 2] = average;
          }
          //回写图像数据并显示结果
          imageData.data = data;
          context.putImageData(imageData, 0, 0);
        };
      }

      function globalAlphaExample() {
        //绘制红色矩形
        context.fillStyle = "#ff0000";
        context.fillRect(10, 10, 50, 50);
        //修改全局透明度
        context.globalAlpha = 0.5;
        //绘制蓝色矩形
        context.fillStyle = "rgba(0,0,255,1)";
        context.fillRect(30, 30, 50, 50);
        //重置全局透明度
        context.globalAlpha = 0;
      }
      function globalCompositionOperationExample() {
        //绘制红色矩形
        context.fillStyle = "#ff0000";
        context.fillRect(10, 10, 50, 50);
        //设置合成操作
        context.globalCompositeOperation = "destination-over";
        //绘制蓝色矩形
        context.fillStyle = "rgba(0,0,255,1)";
        context.fillRect(30, 30, 50, 50);
      }

      function webglExample() {
        // 清空屏幕
        gl.clearColor(0.5, 0.5, 0.5, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // 初始化着色器
        var vs_source = document.getElementById("shader-vs").innerHTML,
          fs_source = document.getElementById("shader-fs").innerHTML;

        // 创建顶点着色器对象
        var vertexShader = gl.createShader(gl.VERTEX_SHADER);
        // 绑定资源
        gl.shaderSource(vertexShader, vs_source);
        // 编译着色器
        gl.compileShader(vertexShader);

        var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fs_source);
        gl.compileShader(fragmentShader);

        // 创建一个着色器程序
        var glProgram = gl.createProgram();

        // 把前面创建的二个着色器对象添加到着色器程序中
        gl.attachShader(glProgram, vertexShader);
        gl.attachShader(glProgram, fragmentShader);

        // 把着色器程序链接成一个完整的程序
        gl.linkProgram(glProgram);

        // 使用这个完整的程序
        gl.useProgram(glProgram);

        // 绘制一个点
        gl.drawArrays(gl.POINTS, 0, 1);
      }

      function checkIsSupportCanvas() {
        var drawing = document.getElementById("drawing");
        //确定浏览器支持<canvas>元素
        if (!drawing.getContext) {
          throw new Error("浏览器不支持canvas");
        }
      }
    </script>
  </body>
</html>
```
