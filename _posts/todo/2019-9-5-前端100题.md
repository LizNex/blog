---
layout: post
title: "前端100题"
subtitle: ""
date: 2019-09-5 12:00:00
author: "左手喝水"
header-img: "img/post-bg-2015.jpg"
tags:
  - js
---

### 前端 100 题

74. 使用 JavaScript Proxy 实现简单的数据绑定

75. 数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多

    时间几乎一致，都是 O(1)复杂的度

76. 输出以下代码运行结果

```js
// example 1
var a={}, b='123', c=123;
a[b]='b';  // a.123 = b
a[c]='c';  // a.123 = c
console.log(a[b]); // c

---------------------
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');
a[b]='b';  //
a[c]='c';  // Symbol唯一值所以不会被覆盖，即使看起来是一样的
console.log(a[b]); //b 只有用Symbol去调才有用

---------------------
// example 3
var a={}, b={key:'123'}, c={key:'456'};
a[b]='b';
a[c]='c'; // 对象会被调用toString变成[object object] 所以两次的key是相同的
console.log(a[b]); // c

```

77. 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1：
输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
输出: [5, 6, 7, 1, 2, 3, 4]
解释:
向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]
向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]
向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]
复制代码示例 2：
输入: [-1, -100, 3, 99] 和 k = 2
输出: [3, 99, -1, -100]
解释:
向右旋转 1 步: [99, -1, -100, 3]
向右旋转 2 步: [3, 99, -1, -100]

```js
function foo(array, k) {
  for (var i = 0; i < k; i++) {
    let temp = array.pop();
    array.unshift(temp);
  }
  return array;
}
```

96. 介绍下前端加密的常见场景和方法

- 登录用户名密码加密
- https
- 爬虫

97. React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？
    // TODO:

98. （京东）写出如下代码的打印结果

```js
function changeObjProperty(o) {
  o.siteUrl = "http://www.baidu.com";
  o = new Object();
  o.siteUrl = "http://www.google.com";
}
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl); //"http://www.baidu.com" 传入的指针，后来修改o的指针所以不会再改变
```

99. （bilibili）编程算法题

> 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。

```js
function filp(int) {
  let str = int + "";
  let char = str[0];
  return str.length === 1 ? char : filp(str.slice(1)) + char;
}
```

100. (京东）请写出如下代码的打印结果

```js
function Foo() {
  Foo.a = function() {
    console.log(1);
  };
  this.a = function() {
    console.log(2);
  };
}
Foo.prototype.a = function() {
  console.log(3);
};
Foo.a = function() {
  console.log(4);
};
Foo.a(); // 4 执行最后一次赋值结果
let obj = new Foo(); // 运行Foo构造函数
obj.a(); //2 构造函数指定this.a
Foo.a(); //1 构造函数赋值Foo.a
```
