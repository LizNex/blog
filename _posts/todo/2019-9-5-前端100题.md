---
layout: post
title: "前端100题"
subtitle: ""
date: 2019-09-5 12:00:00
author: "左手喝水"
header-img: "img/post-bg-2015.jpg"
tags:
  - js
---

### 前端 100 题


65. a.b.c.d 和 a['b']['c']['d']，哪个性能更高？

应该是 a.b.c.d 比 a['b']['c']['d'] 性能高点，后者还要考虑 [ ] 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。


66. ES6 代码转成 ES5 代码的实现思路是什么


// TODO: 待理解
那么 Babel 是如何把 ES6 转成 ES5 呢，其大致分为三步：

将代码字符串解析成抽象语法树，即所谓的 AST
对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码
根据处理后的 AST 再生成代码字符串
基于此，其实我们自己就可以实现一个简单的“编译器”，用于把 ES6 代码转成 ES5。

比如，可以使用 @babel/parser 的 parse 方法，将代码字符串解析成 AST；使用 @babel/core 的 transformFromAstSync 方法，对 AST 进行处理，将其转成 ES5 并生成相应的代码字符串；过程中，可能还需要使用 @babel/traverse 来获取依赖文件等。对此感兴趣的可以看看这个。

67. 随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。

TODO: 自己写一遍

```js

// 得到一个两数之间的随机整数，包括两个数在内
function getRandomIntInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min; //含最大值，含最小值 
}
// 随机生成10个整数数组, 排序, 去重
let initArr = Array.from({ length: 10 }, (v) => { return getRandomIntInclusive(0, 99) });
initArr.sort((a,b) => { return a - b });
initArr = [...(new Set(initArr))];

// 放入hash表
let obj = {};
initArr.map((i) => {
    const intNum = Math.floor(i/10);
    if (!obj[intNum]) obj[intNum] = [];
    obj[intNum].push(i);
})

// 输出结果
const resArr = [];
for(let i in obj) {
    resArr.push(obj[i]);
}
console.log(resArr);
```

68. 如何解决移动端 Retina 屏 1px 像素问题

1 伪元素 + transform scaleY(.5)
2 border-image
3 background-image
4 box-shadow

69. 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC' 变成 'aBc' 。


```js
function processString (s) {
    var arr = s.split('').map((item) => {
        return item === item.toUpperCase() ? item.toLowerCase() : item.toUpperCase();
    });
    return arr.join('');
}
console.log(processString('AbC'));
```


70. 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的

1.当修改了一个或多个文件；
2.文件系统接收更改并通知webpack；
3.webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新；
4.HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp；
5.HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。


71. 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。

indexOf


72. 为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因。

- for 循环没有任何额外的函数调用栈和上下文；

- forEach函数签名实际上是

array.forEach(function(currentValue, index, arr), thisValue)

它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；


73. 介绍下 BFC、IFC、GFC 和 FFC
TODO:


74. 使用 JavaScript Proxy 实现简单的数据绑定
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  </head>
  <body>

    <input type="text" id="input">
    <p id="p"></p>
    <script>
      const input =document.querySelector("#input")
      const p = document.querySelector("#p")
      const text = new Proxy({},{
        get(target,key,value,reciver){
          return Reflect.get(target,key,value)
        },
        set(target,key,value,reciver){
          if(key ==="text"){
            input.value = value
            p.innerHTML = value
          }
          return Reflect.set(...arguments)
        }
      })

      input.addEventListener('keydown',function(e){
        text.text = e.target.value
      })
    </script>
  </body>
</html>

```



75. 数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多

    时间几乎一致，都是 O(1)复杂的度

76. 输出以下代码运行结果

```js
// example 1
var a={}, b='123', c=123;
a[b]='b';  // a.123 = b
a[c]='c';  // a.123 = c
console.log(a[b]); // c

---------------------
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');
a[b]='b';  //
a[c]='c';  // Symbol唯一值所以不会被覆盖，即使看起来是一样的
console.log(a[b]); //b 只有用Symbol去调才有用

---------------------
// example 3
var a={}, b={key:'123'}, c={key:'456'};
a[b]='b';
a[c]='c'; // 对象会被调用toString变成[object object] 所以两次的key是相同的
console.log(a[b]); // c

```

77. 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1：
输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
输出: [5, 6, 7, 1, 2, 3, 4]
解释:
向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]
向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]
向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]
复制代码示例 2：
输入: [-1, -100, 3, 99] 和 k = 2
输出: [3, 99, -1, -100]
解释:
向右旋转 1 步: [99, -1, -100, 3]
向右旋转 2 步: [3, 99, -1, -100]

```js
function foo(array, k) {
  for (var i = 0; i < k; i++) {
    let temp = array.pop();
    array.unshift(temp);
  }
  return array;
}
```

96. 介绍下前端加密的常见场景和方法

- 登录用户名密码加密
- https
- 爬虫

97. React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？
    // TODO:

98. （京东）写出如下代码的打印结果

```js
function changeObjProperty(o) {
  o.siteUrl = "http://www.baidu.com";
  o = new Object();
  o.siteUrl = "http://www.google.com";
}
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl); //"http://www.baidu.com" 传入的指针，后来修改o的指针所以不会再改变
```

99. （bilibili）编程算法题

> 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。

```js
function filp(int) {
  let str = int + "";
  let char = str[0];
  return str.length === 1 ? char : filp(str.slice(1)) + char;
}
```

100. (京东）请写出如下代码的打印结果

```js
function Foo() {
  Foo.a = function() {
    console.log(1);
  };
  this.a = function() {
    console.log(2);
  };
}
Foo.prototype.a = function() {
  console.log(3);
};
Foo.a = function() {
  console.log(4);
};
Foo.a(); // 4 执行最后一次赋值结果
let obj = new Foo(); // 运行Foo构造函数
obj.a(); //2 构造函数指定this.a
Foo.a(); //1 构造函数赋值Foo.a
```


参考：<https://juejin.im/post/5d23e750f265da1b855c7bbe> 前端 100 问：能搞懂 80% 的请把简历给我
