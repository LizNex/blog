---
layout: post
title: "前端100题"
subtitle: ""
date: 2019-09-5 12:00:00
author: "左手喝水"
header-img: "img/post-bg-2015.jpg"
tags:
  - js
---

### 前端 100 题

1.写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？
TODO: 2.['1', '2', '3'].map(parseInt) what & why ?
TODO: 3.什么是防抖和节流？有什么区别？如何实现？
TODO: 4.介绍下 Set、Map、WeakSet 和 WeakMap 的区别？
TODO: 5.介绍下深度优先遍历和广度优先遍历，如何实现？
TODO: 6.请分别用深度优先思想和广度优先思想实现一个拷贝函数？
TODO:
7.ES5/ES6 的继承除了写法以外还有什么区别？
TODO:
8.setTimeout、Promise、Async/Await 的区别
TODO:
9.Async/Await 如何通过同步的方式实现异步
TODO:

10.异步笔试题
请写出下面代码的运行结果

```js
async function async1() {
  console.log("async1 start"); // 2
  await async2();
  console.log("async1 end"); // 6
}
async function async2() {
  console.log("async2"); // 3
}
console.log("script start"); // 1
setTimeout(function() {
  console.log("setTimeout"); // 8
}, 0);
async1();
new Promise(function(resolve) {
  console.log("promise1"); // 4
  resolve();
}).then(function() {
  console.log("promise2"); // 7
});
console.log("script end"); // 5
```

事件循环执行顺序 同步代码->宏任务->宏任务所属微任务
await跟着的表达式会先执行一遍，之后的代码会放到微任务里面等待执行

11.算法手写题
已知如下数组：

var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];

编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

```js
Array.from(new Set(arr.flat(Infinity))).sort((a, b) => {
  return a - b;
});
```

12.JS 异步解决方案的发展历程以及优缺点。
TODO:
13.Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？
TODO: 14.情人节福利题，如何实现一个 new
TODO: 15.：简单讲解一下 http2 的多路复用
TODO: 16.谈谈你对 TCP 三次握手和四次挥手的理解
TODO:
17.A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态
TODO:

18.React 中 setState 什么时候是同步的，什么时候是异步的？
TODO:

19.React setState 笔试题，下面的代码输出什么？

```js
class Example extends React.Component {
  constructor() {
    super();
    this.state = {
      val: 0
    };
  }

  componentDidMount() {
    this.setState({ val: this.state.val + 1 });
    console.log(this.state.val); // 第 1 次 log

    this.setState({ val: this.state.val + 1 });
    console.log(this.state.val); // 第 2 次 log

    setTimeout(() => {
      this.setState({ val: this.state.val + 1 });
      console.log(this.state.val); // 第 3 次 log

      this.setState({ val: this.state.val + 1 });
      console.log(this.state.val); // 第 4 次 log
    }, 0);
  }

  render() {
    return null;
  }
}
```

20.介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？
TODO: 21.有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣 Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()
TODO:

22.介绍下重绘和回流（Repaint & Reflow），以及如何进行优化

1. 浏览器渲染机制
   浏览器采用流式布局模型（Flow Based Layout）
   浏览器会把 HTML 解析成 DOM，把 CSS 解析成 CSSOM，DOM 和 CSSOM 合并就产生了渲染树（Render Tree）。
   有了 RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。
   由于浏览器使用流式布局，对 Render Tree 的计算通常只需要遍历一次就可以完成，但 table 及其内部元素除外，他们可能需要多次计算，通常要花 3 倍于同等元素的时间，这也是为什么要避免使用 table 布局的原因之一。
2. 重绘
   由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如 outline, visibility, color、background-color 等，重绘的代价是高昂的，因为浏览器必须验证 DOM 树上其他节点元素的可见性。

3. 回流
   回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流。

<body>
<div class="error">
    <h4>我的组件</h4>
    <p><strong>错误：</strong>错误的描述…</p>
    <h5>错误纠正</h5>
    <ol>
        <li>第一步</li>
        <li>第二步</li>
    </ol>
</div>
</body>
在上面的HTML片段中，对该段落(<p>标签)回流将会引发强烈的回流，因为它是一个子节点。这也导致了祖先的回流（div.error和body – 视浏览器而定）。此外，<h5>和<ol>也会有简单的回流，因为其在DOM中在回流元素之后。大部分的回流将导致页面的重新渲染。

回流必定会发生重绘，重绘不一定会引发回流。

4. 浏览器优化
   现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即 16.6ms）才会清空队列，但当你获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值。

主要包括以下属性或方法：

offsetTop、offsetLeft、offsetWidth、offsetHeight
scrollTop、scrollLeft、scrollWidth、scrollHeight
clientTop、clientLeft、clientWidth、clientHeight
width、height
getComputedStyle()
getBoundingClientRect()
所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。

5. 减少重绘与回流
   CSS

使用 transform 替代 top

使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局

避免使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局。

尽可能在 DOM 树的最末端改变 class，回流是不可避免的，但可以减少其影响。尽可能在 DOM 树的最末端改变 class，可以限制了回流的范围，使其影响尽可能少的节点。

避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。

```html
<div>
  <a> <span></span> </a>
</div>
<style>
  span {
    color: red;
  }
  div > a > span {
    color: red;
  }
</style>
```

对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。

将动画效果应用到 position 属性为 absolute 或 fixed 的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。

避免使用 CSS 表达式，可能会引发回流。

将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如 will-change、video、iframe 等标签，浏览器会自动将该节点变为图层。

CSS3 硬件加速（GPU 加速），使用 css3 硬件加速，可以让 transform、opacity、filters 这些动画不会引起回流重绘 。但是对于动画的其它属性，比如 background-color 这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

JavaScript

避免频繁操作样式，最好一次性重写 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。
避免频繁操作 DOM，创建一个 documentFragment，在它上面应用所有 DOM 操作，最后再把它添加到文档中。
避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

23.介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景
TODO:

24.聊聊 Redux 和 Vuex 的设计思想
TODO:

25:说说浏览器和 Node 事件循环的区别
TODO:

26.介绍模块化发展历程
TODO:

27.关于 const 和 let 声明的变量不在 window 上
es6 中规定不再 window 上，但在全局（Global）的作用于之中

28.cookie 和 token 都存放在 header 中，为什么不会劫持 token？

首先 token 不是防止 XSS 的，而是为了防止 CSRF 的；
CSRF 攻击的原因是浏览器会自动带上 cookie，而浏览器不会自动带上 token

29.聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的
TODO:

30.两个数组合并成一个数组

请把两个数组 ['A1', 'A2', 'B1', 'B2', 'C1', 'C2', 'D1', 'D2'] 和 ['A', 'B', 'C', 'D']，合并为 ['A1', 'A2', 'A', 'B1', 'B2', 'B', 'C1', 'C2', 'C', 'D1', 'D2', 'D']。

````js
var arr1 = ["A1", "A2", "B1", "B2", "C1", "C2", "D1", "D2"]
var arr2 = ["A", "B", "C", "D"]
var arr3 = arr1.concat(arr2);
arr3.sort().sort(function(a,b){
   if (a.charAt(0) == b.charAt(0) && a.length > b.length){
       return -1
   }

})
```

````

31.改造下面的代码，使之输出 0 - 9，写出你能想到的所有解法

```js
for (var i = 0; i < 10; i++) {
  setTimeout(
    i => {
      console.log(i);
    },
    1000,
    i
  );
}
```

32.Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想
TODO:

33.下面的代码打印什么内容，为什么？
函数内部不可以修改函数，此时函数为只读

34.简单改造下面的代码，使之分别打印 10 和 20。

```js

// 打印 20 :

var b = 10;
(function (){
  b = 20;
  console.log(b);
})();
// 打印 10:

var b = 10;
(function (){
  console.log(b);
  b = 20;
```

35.浏览器缓存读取规则
可以分成 Service Worker、Memory Cache、Disk Cache 和 Push Cache，那请求的时候 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache 中？

TODO: 待看

36.使用迭代的方式实现 flatten 函数。

```js
let arr = [1, 2, [3, 4, 5, [6, 7], 8], 9, 10, [11, [12, 13]]];

const flatten = function(arr) {
  while (arr.some(item => Array.isArray(item))) {
    arr = [].concat(...arr);
  }
  return arr;
};

console.log(flatten(arr));
```

37.为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？
TODO: 38.下面代码中 a 在什么情况下会打印 1？

```js
var a = {
  i: 1,
  toString() {
    return a.i++;
  }
};

if (a == 1 && a == 2 && a == 3) {
  console.log(1);
}
```

39.介绍下 BFC 及其应用。
TODO:

40.在 Vue 中，子组件为何不可以修改父组件传递的 Prop

单向数据流动可以快速定位问题

41.下面代码输出什么

```js
var a = 10;
(function() {
  console.log(a); // undefined var a = 20 的a变量提升
  a = 5; // 变量提升的a赋值，不影响外部的a
  console.log(window.a); // 10  外部的a不受影响
  var a = 20; // 内部a再次赋值
  console.log(a); // 20
})();
```

42.实现一个 sleep 函数，比如 sleep(1000) 意味着等待 1000 毫秒，可从 Promise、Generator、Async/Await 等角度实现

```js
//Promise
const sleep = time => {
  return new Promise(resolve => setTimeout(resolve, time));
};
sleep(1000).then(() => {
  console.log(1);
});

//Generator
function* sleepGenerator(time) {
  yield new Promise(function(resolve, reject) {
    setTimeout(resolve, time);
  });
}
sleepGenerator(1000)
  .next()
  .value.then(() => {
    console.log(1);
  });

//async
function sleep(time) {
  return new Promise(resolve => setTimeout(resolve, time));
}
async function output() {
  let out = await sleep(1000);
  console.log(1);
  return out;
}
output();

//ES5
function sleep(callback, time) {
  if (typeof callback === "function") setTimeout(callback, time);
}
function output() {
  console.log(1);
}
sleep(output, 1000);
```

43.使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果

```js
[3, 15, 8, 29, 102, 22].sort(function(a, b) {
  return a - b;
});
```

44.介绍 HTTPS 握手过程

1.客户端使用 https 的 url 访问 web 服务器,要求与服务器建立 ssl 连接
2.web 服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端 3.客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥 4.客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥 5.之后服务器与客户端使用秘钥加密传输

45.HTTPS 握手过程中，客户端如何验证证书的合法性
浏览器用内置的各大认证机构的公钥，用公钥解密证书的签名和自己使用公钥再生产一份比对是否相同，如果相同则证书有效；签名是使用网站域名的等信息交给机构加密生成

46.

```js
var obj = {
  "2": 3,
  "3": 4,
  length: 2,
  splice: Array.prototype.splice,
  push: Array.prototype.push
};
obj.push(1);
obj.push(2);
console.log(obj);
```

push 到时候根据 length 属性来添加，比如 length=2 的时候 push 执行的就是 obj[2]=1

47.双向绑定和 vuex 是否冲突

TODO:待看

48.call 和 apply 的区别是什么，哪个性能更好一些
unction.prototype.apply 和 Function.prototype.call 的作用是一样的，区别在于传入参数的不同；
第一个参数都是，指定函数体内 this 的指向；
第二个参数开始不同，apply 是传入带下标的集合，数组或者类数组，apply 把它传给函数作为参数，call 从第二个开始传入的参数是不固定的，都会传给函数作为参数。
call 比 apply 的性能要好，平常可以多用 call, call 传入参数的格式正是内部所需要的格式 49.为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片
能够完成整个 HTTP 请求+响应（尽管不需要响应内容）
触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据
跨域友好
执行过程无阻塞
相比 XMLHttpRequest 对象发送 GET 请求，性能上更好
GIF 的最低合法体积最小（最小的 BMP 文件需要 74 个字节，PNG 需要 67 个字节，而合法的 GIF，只需要 43 个字节）

50.实现 (5).add(3).minus(2) 功能。

```js
Number.prototype.add = function(n) {
  return this.valueOf() + n;
};
Number.prototype.minus = function(n) {
  return this.valueOf() - n;
};
```

51.Vue 的响应式原理中 Object.defineProperty 有什么缺陷
object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
Object.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。Proxy 可以劫持整个对象，并返回一个新的对象。
Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。

52.怎么让一个 div 水平垂直居中

```html
<div class="parent">
  <div class="child"></div>
</div>
```

```css
div.parent {
  display: flex;
  justify-content: center;
  align-items: center;
}
div.parent {
  position: relative;
}
div.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
/* 或者 */
div.child {
  width: 50px;
  height: 10px;
  position: absolute;
  top: 50%;
  left: 50%;
  margin-left: -25px;
  margin-top: -5px;
}
/* 或 */
div.child {
  width: 50px;
  height: 10px;
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  margin: auto;
}
div.parent {
  display: grid;
}
div.child {
  justify-self: center;
  align-self: center;
}
div.parent {
  font-size: 0;
  text-align: center;
  &::before {
    content: "";
    display: inline-block;
    width: 0;
    height: 100%;
    vertical-align: middle;
  }
}
div.child {
  display: inline-block;
  vertical-align: middle;
}
```

53.输出以下代码的执行结果并解释为什么

```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };

console.log(a.x); // undefind
console.log(b.x); // {n:2}
```

TODO: 不是很理解
1、优先级。.的优先级高于=，所以先执行 a.x，堆内存中的{n: 1}就会变成{n: 1, x: undefined}，改变之后相应的 b.x 也变化了，因为指向的是同一个对象。
2、赋值操作是从右到左，所以先执行 a = {n: 2}，a 的引用就被改变了，然后这个返回值又赋值给了 a.x，需要注意的是这时候 a.x 是第一步中的{n: 1, x: undefined}那个对象，其实就是 b.x，相当于 b.x = {n: 2}

54.冒泡排序如何实现，时间复杂度是多少， 还可以如何改进？

```js TODO:有空看一下
function bubbleSort2(arr) {
  let low = 0;
  let high = arr.length - 1;
  let temp, j;

  while (low < high) {
    // 正排找最大
    for (j = low; j < high; ++j) {
      if (arr[j] > arr[j + 1]) {
        temp = arr[j];
        arr[j] = arr[j + 1];
        arr[j + 1] = temp;
      }
    }
    --high;

    // 反排找最小
    for (j = high; j > low; --j) {
      if (arr[j] < arr[j - 1]) {
        temp = arr[j];
        arr[j] = arr[j - 1];
        arr[j - 1] = temp;
      }
    }
    ++low;
  }
  console.log(arr);
}
```

55.某公司 1 到 12 月份的销售额存在一个对象里面，如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]。

```js
let obj = { 1: 222, 2: 123, 5: 888 };
const result = Array.from({ length: 12 }).map(
  (_, index) => obj[index + 1] || null
);
console.log(result);
```

56.要求设计 LazyMan 类，实现以下功能。

```js
LazyMan("Tony");
// Hi I am Tony

LazyMan("Tony")
  .sleep(10)
  .eat("lunch");
// Hi I am Tony
// 等待了10秒...
// I am eating lunch

LazyMan("Tony")
  .eat("lunch")
  .sleep(10)
  .eat("dinner");
// Hi I am Tony
// I am eating lunch
// 等待了10秒...
// I am eating diner

LazyMan("Tony")
  .eat("lunch")
  .eat("dinner")
  .sleepFirst(5)
  .sleep(10)
  .eat("junk food");
// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food
```

```js
class LazyManClass {
  constructor(name) {
    this.taskList = [];
    this.name = name;
    console.log(`Hi I am ${name}`);
    setTimeout(() => {
      this.start();
    }, 0);
  }

  eat(sth) {
    this.taskList.push(function() {
      console.log(`I am eating ${sth}`);
    });
    return this;
  }
  sleep(s) {
    this.taskList.push(this.delay(s));
    return this;
  }
  delay(s) {
    return () => {
      return new Promise((resolve, reject) => {
        console.log(`等待了${s}秒...`);
        resolve();
      }, s * 1000);
    };
  }
  sleepFirst(s) {
    this.taskList.unshift(this.delay(s));
    return this;
  }
  async start() {
    for (let task of this.taskList) {
      await task();
    }
  }
}

function LazyMan(name) {
  return new LazyManClass(name)
    .eat("lunch")
    .eat("dinner")
    .sleepFirst(5)
    .sleep(10)
    .eat("junk food");
}
LazyMan("Tony");
```

57.分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景
display: none (不占空间，不能点击)（场景，显示出原来这里不存在的结构）
visibility: hidden（占据空间，不能点击）（场景：显示不会导致页面结构发生变动，不会撑开）
opacity: 0（占据空间，可以点击）（场景：可以跟 transition 搭配）

58.箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？

箭头函数是普通函数的简写，可以更优雅的定义一个函数，和普通函数相比，有以下几点差异：

1、函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。

2、不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。

3、不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。

4、不可以使用 new 命令，因为：

没有自己的 this，无法调用 call，apply。
没有 prototype 属性 ，而 new 命令在执行时需要将构造函数的 prototype 赋值给新的对象的 **proto**
new 过程大致是这样的：

```js
function newFunc(father, ...rest) {
  var result = {};
  result.__proto__ = father.prototype;
  var result2 = father.apply(result, rest);
  if (
    (typeof result2 === "object" || typeof result2 === "function") &&
    result2 !== null
  ) {
    return result2;
  }
  return result;
}
```

59.给定两个数组，写一个方法来计算它们的交集。
这道题两种思路，空间换时间，或者不用额外空间就提升时间复杂度。

空间换时间的思路是用个 Hash 表来存数组 1 的元素以及出现的个数（此处需要遍历 n 次，并存一个 n 级别的空间）。
遍历数组 2，发现数组 2 里有 Hash 表里的值就存到 Result 数组里，并把 Hash 表内该值次数减一（为 0 之后就 Delete）。如果不存在 Hash 表里，就跳过。这样时间复杂度就是(m+n)

不用额外空间，就用遍历 n 的时候，判断值在不在 m 里，如果在，把 m 里的该值 push 到 Result 数组里，并将该值从 m 数组里删掉（用 splice）。这样就是不用额外空间，但是提高了时间复杂度。

```js
function intersection(arr1, arr2) {
  let hash = {};
  let result = [];
  for (let item1 of arr1) {
    hash[item1] = hash[item1] ? hash[item1] + 1 : 1;
  }
  for (let item2 of arr2) {
    if (hash[item2] && hash[item2] > 0) {
      hash[item2]--;
      result.push(item2);
    }
  }
  return result;
}
```

60.已知如下代码，如何修改才能让图片宽度为 300px ？注意下面代码不可修改。
max-width

61.介绍下如何实现 token 加密
需要一个 secret（随机数）
后端利用 secret 和加密算法(如：HMAC-SHA256)对 payload(如账号密码)生成一个字符串(token)，返回前端
前端每次 request 在 header 中带上 token
后端用同样的算法解密

62.redux 为什么要把 reducer 设计成纯函数
TODO:对 react 不了解

63.如何设计实现无缝轮播
克隆首尾元素放在首尾巴，当切换到克隆元素替换到真正到元素上 64.模拟实现一个 Promise.finally

```js TODO:不知道为什么要返回
Promise.prototype.finally = function(callback) {
  let P = this.constructor;
  return this.then(
    value => P.resolve(callback()).then(() => value),
    reason =>
      P.resolve(callback()).then(() => {
        throw reason;
      })
  );
};
```

克隆

1.  使用 JavaScript Proxy 实现简单的数据绑定

2.  数组里面有 10 万个数据，取第一个元素和第 10 万个元素的时间相差多

    时间几乎一致，都是 O(1)复杂的度

3.  输出以下代码运行结果

```js
// example 1
var a={}, b='123', c=123;
a[b]='b';  // a.123 = b
a[c]='c';  // a.123 = c
console.log(a[b]); // c

---------------------
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');
a[b]='b';  //
a[c]='c';  // Symbol唯一值所以不会被覆盖，即使看起来是一样的
console.log(a[b]); //b 只有用Symbol去调才有用

---------------------
// example 3
var a={}, b={key:'123'}, c={key:'456'};
a[b]='b';
a[c]='c'; // 对象会被调用toString变成[object object] 所以两次的key是相同的
console.log(a[b]); // c

```

65. a.b.c.d 和 a['b']['c']['d']，哪个性能更高？

应该是 a.b.c.d 比 a['b']['c']['d'] 性能高点，后者还要考虑 [ ] 中是变量的情况，再者，从两种形式的结构来看，显然编译器解析前者要比后者容易些，自然也就快一点。


66. ES6 代码转成 ES5 代码的实现思路是什么


// TODO: 待理解
那么 Babel 是如何把 ES6 转成 ES5 呢，其大致分为三步：

将代码字符串解析成抽象语法树，即所谓的 AST
对 AST 进行处理，在这个阶段可以对 ES6 代码进行相应转换，即转成 ES5 代码
根据处理后的 AST 再生成代码字符串
基于此，其实我们自己就可以实现一个简单的“编译器”，用于把 ES6 代码转成 ES5。

比如，可以使用 @babel/parser 的 parse 方法，将代码字符串解析成 AST；使用 @babel/core 的 transformFromAstSync 方法，对 AST 进行处理，将其转成 ES5 并生成相应的代码字符串；过程中，可能还需要使用 @babel/traverse 来获取依赖文件等。对此感兴趣的可以看看这个。

67. 随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。

TODO: 自己写一遍

```js

// 得到一个两数之间的随机整数，包括两个数在内
function getRandomIntInclusive(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min; //含最大值，含最小值 
}
// 随机生成10个整数数组, 排序, 去重
let initArr = Array.from({ length: 10 }, (v) => { return getRandomIntInclusive(0, 99) });
initArr.sort((a,b) => { return a - b });
initArr = [...(new Set(initArr))];

// 放入hash表
let obj = {};
initArr.map((i) => {
    const intNum = Math.floor(i/10);
    if (!obj[intNum]) obj[intNum] = [];
    obj[intNum].push(i);
})

// 输出结果
const resArr = [];
for(let i in obj) {
    resArr.push(obj[i]);
}
console.log(resArr);
```

68. 如何解决移动端 Retina 屏 1px 像素问题

1 伪元素 + transform scaleY(.5)
2 border-image
3 background-image
4 box-shadow

69. 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC' 变成 'aBc' 。


```js
function processString (s) {
    var arr = s.split('').map((item) => {
        return item === item.toUpperCase() ? item.toLowerCase() : item.toUpperCase();
    });
    return arr.join('');
}
console.log(processString('AbC'));
```


70. 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的

1.当修改了一个或多个文件；
2.文件系统接收更改并通知webpack；
3.webpack重新编译构建一个或多个模块，并通知HMR服务器进行更新；
4.HMR Server 使用webSocket通知HMR runtime 需要更新，HMR运行时通过HTTP请求更新jsonp；
5.HMR运行时替换更新中的模块，如果确定这些模块无法更新，则触发整个页面刷新。


71. 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。

indexOf


72. 为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因。

- for 循环没有任何额外的函数调用栈和上下文；

- forEach函数签名实际上是

array.forEach(function(currentValue, index, arr), thisValue)

它不是普通的 for 循环的语法糖，还有诸多参数和上下文需要在执行的时候考虑进来，这里可能拖慢性能；


73. 介绍下 BFC、IFC、GFC 和 FFC
TODO:


74. 使用 JavaScript Proxy 实现简单的数据绑定
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  </head>
  <body>

    <input type="text" id="input">
    <p id="p"></p>
    <script>
      const input =document.querySelector("#input")
      const p = document.querySelector("#p")
      const text = new Proxy({},{
        get(target,key,value,reciver){
          return Reflect.get(target,key,value)
        },
        set(target,key,value,reciver){
          if(key ==="text"){
            input.value = value
            p.innerHTML = value
          }
          return Reflect.set(...arguments)
        }
      })

      input.addEventListener('keydown',function(e){
        text.text = e.target.value
      })
    </script>
  </body>
</html>

```

77. 给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

示例 1：
输入: [1, 2, 3, 4, 5, 6, 7] 和 k = 3
输出: [5, 6, 7, 1, 2, 3, 4]
解释:
向右旋转 1 步: [7, 1, 2, 3, 4, 5, 6]
向右旋转 2 步: [6, 7, 1, 2, 3, 4, 5]
向右旋转 3 步: [5, 6, 7, 1, 2, 3, 4]
复制代码示例 2：
输入: [-1, -100, 3, 99] 和 k = 2
输出: [3, 99, -1, -100]
解释:
向右旋转 1 步: [99, -1, -100, 3]
向右旋转 2 步: [3, 99, -1, -100]

```js
function foo(array, k) {
  for (var i = 0; i < k; i++) {
    let temp = array.pop();
    array.unshift(temp);
  }
  return array;
}
```

96. 介绍下前端加密的常见场景和方法

- 登录用户名密码加密
- https
- 爬虫

97. React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？
    // TODO:

98. （京东）写出如下代码的打印结果

```js
function changeObjProperty(o) {
  o.siteUrl = "http://www.baidu.com";
  o = new Object();
  o.siteUrl = "http://www.google.com";
}
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl); //"http://www.baidu.com" 传入的指针，后来修改o的指针所以不会再改变
```

99. （bilibili）编程算法题

> 用 JavaScript 写一个函数，输入 int 型，返回整数逆序后的字符串。如：输入整型 1234，返回字符串“4321”。要求必须使用递归函数调用，不能用全局变量，输入函数必须只有一个参数传入，必须返回字符串。

```js
function filp(int) {
  let str = int + "";
  let char = str[0];
  return str.length === 1 ? char : filp(str.slice(1)) + char;
}
```

100. (京东）请写出如下代码的打印结果

```js
function Foo() {
  Foo.a = function() {
    console.log(1);
  };
  this.a = function() {
    console.log(2);
  };
}
Foo.prototype.a = function() {
  console.log(3);
};
Foo.a = function() {
  console.log(4);
};
Foo.a(); // 4 执行最后一次赋值结果
let obj = new Foo(); // 运行Foo构造函数
obj.a(); //2 构造函数指定this.a
Foo.a(); //1 构造函数赋值Foo.a
```

<<<<<<< HEAD

参考：<https://juejin.im/post/5d23e750f265da1b855c7bbe> 前端 100 问：能搞懂 80% 的请把简历给我
=======
参考：
前端面试题：<https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md>
>>>>>>> d4d54ccb75e36bc74fe64b96d63a74beba2b1b28
